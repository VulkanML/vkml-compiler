Passes:
  --affine-data-copy-generate                        -   Generate explicit copying for affine memory operations
    --fast-mem-capacity=<ulong>                      - Set fast memory space capacity in KiB (default: unlimited)
    --fast-mem-space=<uint>                          - Fast memory space identifier for copy generation (default: 1)
    --generate-dma                                   - Generate DMA instead of point-wise copy
    --min-dma-transfer=<int>                         - Minimum DMA transfer size supported by the target in bytes
    --skip-non-unit-stride-loops                     - Testing purposes: avoid non-unit stride loop choice depths for copy placement
    --slow-mem-space=<uint>                          - Slow memory space identifier for copy generation (default: 0)
    --tag-mem-space=<uint>                           - Tag memory space identifier for copy generation (default: 0)
  --affine-expand-index-ops                          -   Lower affine operations operating on indices into more fundamental operations
  --affine-expand-index-ops-as-affine                -   Lower affine operations operating on indices into affine.apply operations
  --affine-loop-coalescing                           -   Coalesce nested loops with independent bounds into a single loop
  --affine-loop-fusion                               -   Fuse affine loop nests
    --fusion-compute-tolerance=<number>              - Fractional increase in additional computation tolerated while fusing
    --fusion-fast-mem-space=<uint>                   - Faster memory space number to promote fusion buffers to
    --fusion-local-buf-threshold=<ulong>             - Threshold size (KiB) for promoting local buffers to fast memory space
    --fusion-maximal                                 - Enables maximal loop fusion
    --mode=<value>                                   - fusion mode to attempt
    =greedy                                        -   Perform greedy (both producer-consumer and sibling)  fusion
    =producer                                      -   Perform only producer-consumer fusion
    =sibling                                       -   Perform only sibling fusion
  --affine-loop-invariant-code-motion                -   Hoist loop invariant instructions outside of affine loops
  --affine-loop-normalize                            -   Apply normalization transformations to affine loop-like ops
    --promote-single-iter                            - Promote single iteration loops
  --affine-loop-tile                                 -   Tile affine loop nests
    --cache-size=<ulong>                             - Set size of cache to tile for in KiB (default: 512)
    --separate                                       - Separate full and partial tiles (default: false)
    --tile-size=<uint>                               - Use this tile size for all loops
    --tile-sizes=<uint>                              - List of tile sizes for each perfect nest (overridden by -tile-size)
  --affine-loop-unroll                               -   Unroll affine loops
    --cleanup-unroll                                 - Fully unroll the cleanup loop when possible.
    --unroll-factor=<uint>                           - Use this unroll factor for all loops being unrolled
    --unroll-full                                    - Fully unroll loops
    --unroll-full-threshold=<uint>                   - Unroll all loops with trip count less than or equal to this
    --unroll-num-reps=<uint>                         - Unroll innermost loops repeatedly this many times
    --unroll-up-to-factor                            - Allow unrolling up to the factor specified
  --affine-loop-unroll-jam                           -   Unroll and jam affine loops
    --unroll-jam-factor=<uint>                       - Use this unroll jam factor for all loops (default 4)
  --affine-parallelize                               -   Convert affine.for ops into 1-D affine.parallel
    --max-nested=<uint>                              - Maximum number of nested parallel loops to produce. Defaults to unlimited (UINT_MAX).
    --parallel-reductions                            - Whether to parallelize reduction loops. Defaults to false.
  --affine-pipeline-data-transfer                    -   Pipeline non-blocking data transfers between explicitly managed levels of the memory hierarchy
  --affine-scalrep                                   -   Replace affine memref accesses by scalars by forwarding stores to loads and eliminating redundant loads
  --affine-simplify-structures                       -   Simplify affine expressions in maps/sets and normalize memrefs
  --affine-super-vectorize                           -   Vectorize to a target independent n-D vector abstraction
    --test-fastest-varying=<long>                    - Specify a 1-D, 2-D or 3-D pattern of fastest varying memory dimensions to match. See defaultPatterns in Vectorize.cpp for a description and examples. This is used for testing purposes
    --vectorize-reductions                           - Vectorize known reductions expressed via iter_args. Switched off by default.
    --virtual-vector-size=<long>                     - Specify an n-D virtual vector size for vectorization. This must be greater than zero.
  --amdgpu-emulate-atomics                           -   Emulate atomic operations on chipsets that do not support them
    --chipset=<string>                               - Chipset that these operations will run on
  --arith-emulate-unsupported-floats                 -   Emulate operations on unsupported floats with extf/truncf
    --source-types=<string>                          - MLIR types without arithmetic support on a given target
    --target-type=<string>                           - MLIR type to convert the unsupported source types to
  --arith-emulate-wide-int                           -   Emulate 2*N-bit integer operations using N-bit operations
    --widest-int-supported=<uint>                    - Widest integer type supported by the target
  --arith-expand                                     -   Legalize Arith ops to be convertible to LLVM.
    --include-bf16                                   - Enable the BF16 expansion patterns
  --arith-int-range-narrowing                        -   Reduce integer operations bitwidth based on integer range analysis
    --int-bitwidths-supported=<uint>                 - Integer bitwidths supported
  --arith-unsigned-when-equivalent                   -   Replace signed ops with unsigned ones where they are proven equivalent
  --arm-neon-2d-to-intr                              -   Convert Arm NEON structured ops to intrinsics
  --arm-sme-outer-product-fusion                     -   Fuse 'arm_sme.outerproduct' operations into 2-way or 4-way widening variants
  --arm-sme-vector-legalization                      -   Legalize vectors for ArmSME
  --arm-sve-legalize-vector-storage                  -   Ensures stores of SVE vector types will be legal
  --async-func-to-async-runtime                      -   Lower async.func operations to the explicit async.runtime andasync.coro operations
  --async-parallel-for                               -   Convert scf.parallel operations to multiple async compute ops executed concurrently for non-overlapping iteration ranges
    --async-dispatch                                 - Dispatch async compute tasks using recursive work splitting. If `false` async compute tasks will be launched using simple for loop in the caller thread.
    --min-task-size=<int>                            - The minimum task size for sharding parallel operation.
    --num-workers=<int>                              - The number of available workers to execute async operations. If `-1` the value will be retrieved from the runtime.
  --async-runtime-policy-based-ref-counting          -   Policy based reference counting for Async runtime operations
  --async-runtime-ref-counting                       -   Automatic reference counting for Async runtime operations
  --async-runtime-ref-counting-opt                   -   Optimize automatic reference counting operations for theAsync runtime by removing redundant operations
  --async-to-async-runtime                           -   Lower all high level async operations (e.g. async.execute) tothe explicit async.runtime and async.coro operations
  --buffer-deallocation                              -   Adds all required dealloc operations for all allocations in the input program
  --buffer-deallocation-simplification               -   Optimizes `bufferization.dealloc` operation for more efficient codegen
  --buffer-hoisting                                  -   Optimizes placement of allocation operations by moving them into common dominators and out of nested regions
  --buffer-loop-hoisting                             -   Optimizes placement of allocation operations by moving them out of loop nests
  --buffer-results-to-out-params                     -   Converts memref-typed function results to out-params
    --add-result-attr                                - Add the attribute 'bufferize.result' to all output parameters.
    --hoist-static-allocs                            - Hoist static allocations to call sites.
  --bufferization-lower-deallocations                -   Lowers `bufferization.dealloc` operations to `memref.dealloc`operations
  --canonicalize                                     -   Canonicalize operations
    --disable-patterns=<string>                      - Labels of patterns that should be filtered out during application
    --enable-patterns=<string>                       - Labels of patterns that should be used during application, all other patterns are filtered out
    --max-iterations=<long>                          - Max. iterations between applying patterns / simplifying regions
    --max-num-rewrites=<long>                        - Max. number of pattern rewrites within an iteration
    --region-simplify=<value>                        - Perform control flow optimizations to the region tree
    =disabled                                      -   Don't run any control-flow simplification.
    =normal                                        -   Perform simple control-flow simplifications (e.g. dead args elimination).
    =aggressive                                    -   Perform aggressive control-flow simplification (e.g. block merging).
    --test-convergence                               - Test only: Fail pass on non-convergence to detect cyclic pattern
    --top-down                                       - Seed the worklist in general top-down order
  --composite-fixed-point-pass                       -   Composite fixed point pass
    --max-iterations=<int>                           - Maximum number of iterations if inner pipeline
    --name=<string>                                  - Composite pass display name
    --pipeline=<string>                              - Composite pass inner pipeline
  --control-flow-sink                                -   Sink operations into conditional blocks
  --convert-affine-for-to-gpu                        -   Convert top-level AffineFor Ops to GPU kernels
    --gpu-block-dims=<uint>                          - Number of GPU block dimensions for mapping
    --gpu-thread-dims=<uint>                         - Number of GPU thread dimensions for mapping
  --convert-amdgpu-to-rocdl                          -   Convert AMDGPU dialect to ROCDL dialect
    --chipset=<string>                               - Chipset that these operations will run on
  --convert-arith-to-amdgpu                          -   Convert Arith operations to AMDGPU-specific implementations
    --allow-packed-f16-round-to-zero                 - Whether we should allow f32->f16 packed round-to-zero conversion
    --chipset=<string>                               - Chipset that these operations will run on
    --saturate-fp8-truncf                            - Use saturating truncation for 8-bit float types
  --convert-arith-to-arm-sme                         -   Convert Arith dialect to ArmSME dialect
  --convert-arith-to-emitc                           -   Convert Arith dialect to EmitC dialect
  --convert-arith-to-llvm                            -   Convert Arith dialect to LLVM dialect
    --index-bitwidth=<uint>                          - Bitwidth of the index type, 0 to use size of machine word
  --convert-arith-to-spirv                           -   Convert Arith dialect to SPIR-V dialect
    --emulate-lt-32-bit-scalar-types                 - Emulate narrower scalar types with 32-bit ones if not supported by the target
  --convert-arm-sme-to-llvm                          -   Lower the operations from the ArmSME dialect into the LLVM dialect
    --dump-tile-live-ranges                          - Dump the live ranges of SME tiles (for debugging)
  --convert-arm-sme-to-scf                           -   Lower the operations from the ArmSME dialect into the SCF dialect
  --convert-async-to-llvm                            -   Convert the operations from the async dialect into the LLVM dialect
  --convert-bufferization-to-memref                  -   Convert operations from the Bufferization dialect to the MemRef dialect
  --convert-cf-to-llvm                               -   Convert ControlFlow operations to the LLVM dialect
    --index-bitwidth=<uint>                          - Bitwidth of the index type, 0 to use size of machine word
  --convert-cf-to-spirv                              -   Convert ControlFlow dialect to SPIR-V dialect
    --emulate-lt-32-bit-scalar-types                 - Emulate narrower scalar types with 32-bit ones if not supported by the target
  --convert-complex-to-libm                          -   Convert Complex dialect to libm calls
  --convert-complex-to-llvm                          -   Convert Complex dialect to LLVM dialect
  --convert-complex-to-spirv                         -   Convert Complex dialect to SPIRV dialect
  --convert-complex-to-standard                      -   Convert Complex dialect to standard dialect
  --convert-elementwise-to-linalg                    -   Convert ElementwiseMappable ops to linalg
  --convert-func-to-emitc                            -   Convert Func dialect to EmitC dialect
  --convert-func-to-llvm                             -   Convert from the Func dialect to the LLVM dialect
    --index-bitwidth=<uint>                          - Bitwidth of the index type, 0 to use size of machine word
    --use-bare-ptr-memref-call-conv                  - Replace FuncOp's MemRef arguments with bare pointers to the MemRef element types
  --convert-func-to-spirv                            -   Convert Func dialect to SPIR-V dialect
    --emulate-lt-32-bit-scalar-types                 - Emulate narrower scalar types with 32-bit ones if not supported by the target
  --convert-gpu-launch-to-vulkan-launch              -   Convert gpu.launch_func to vulkanLaunch external call
  --convert-gpu-to-llvm-spv                          -   Generate LLVM operations to be ingested by a SPIR-V backend for gpu operations
    --use-64bit-index                                - Use 64-bit integers to convert index types
  --convert-gpu-to-nvvm                              -   Generate NVVM operations for gpu operations
    --has-redux                                      - Target gpu supports redux
    --index-bitwidth=<uint>                          - Bitwidth of the index type, 0 to use size of machine word
    --use-bare-ptr-memref-call-conv                  - Replace memref arguments in GPU functions with bare pointers. All memrefs must have static shape.
  --convert-gpu-to-rocdl                             -   Generate ROCDL operations for gpu operations
    --chipset=<string>                               - Chipset that these operations will run on
    --index-bitwidth=<uint>                          - Bitwidth of the index type, 0 to use size of machine word
    --runtime=<value>                                - Runtime code will be run on (default is Unknown, can also use HIP or OpenCl)
    =unknown                                       -   Unknown (default)
    =HIP                                           -   HIP
    =OpenCL                                        -   OpenCL
    --use-bare-ptr-memref-call-conv                  - Replace memref arguments in GPU functions with bare pointers.All memrefs must have static shape
  --convert-gpu-to-spirv                             -   Convert GPU dialect to SPIR-V dialect
    --use-64bit-index                                - Use 64-bit integers to convert index types
  --convert-index-to-llvm                            -   Lower the `index` dialect to the `llvm` dialect.
    --index-bitwidth=<uint>                          - Bitwidth of the index type, 0 to use size of machine word
  --convert-index-to-spirv                           -   Lower the `index` dialect to the `spirv` dialect.
    --use-64bit-index                                - Use 64-bit integers to convert index types
  --convert-linalg-to-affine-loops                   -   Lower the operations from the linalg dialect into affine loops
  --convert-linalg-to-loops                          -   Lower the operations from the linalg dialect into loops
  --convert-linalg-to-parallel-loops                 -   Lower the operations from the linalg dialect into parallel loops
  --convert-linalg-to-std                            -   Convert the operations from the linalg dialect into the Standard dialect
  --convert-math-to-emitc                            -   Convert some Math operations to EmitC call_opaque operations
    --language-target=<value>                        - Select the language standard target for callees (c99 or cpp11).
    =c99                                           -   c99
    =cpp11                                         -   cpp11
  --convert-math-to-funcs                            -   Convert Math operations to calls of outlined implementations.
    --convert-ctlz                                   - Convert math.ctlz to a software implementation. Enable for targets that do not natively support ctlz.
    --min-width-of-fpowi-exponent=<uint>             - Convert FPowI only if the width of its exponent's integer type is greater than or equal to this value
  --convert-math-to-libm                             -   Convert Math dialect to libm calls
  --convert-math-to-llvm                             -   Convert Math dialect to LLVM dialect
    --approximate-log1p                              - Enable approximation of Log1p.
  --convert-math-to-rocdl                            -   Convert Math dialect to ROCDL library calls
  --convert-math-to-spirv                            -   Convert Math dialect to SPIR-V dialect
  --convert-memref-to-emitc                          -   Convert MemRef dialect to EmitC dialect
  --convert-memref-to-spirv                          -   Convert MemRef dialect to SPIR-V dialect
    --bool-num-bits=<int>                            - The number of bits to store a boolean value
    --use-64bit-index                                - Use 64-bit integers to convert index types
  --convert-mesh-to-mpi                              -   Convert Mesh dialect to MPI dialect.
  --convert-nvgpu-to-nvvm                            -   Convert NVGPU dialect to NVVM dialect
  --convert-nvvm-to-llvm                             -   Convert NVVM to PTX with Inline Assembly in LLVM dialect
  --convert-openacc-to-scf                           -   Convert the OpenACC ops to OpenACC with SCF dialect
  --convert-openmp-to-llvm                           -   Convert the OpenMP ops to OpenMP ops with LLVM dialect
  --convert-parallel-loops-to-gpu                    -   Convert mapped scf.parallel ops to gpu launch operations
  --convert-pdl-to-pdl-interp                        -   Convert PDL ops to PDL interpreter ops
  --convert-scf-to-cf                                -   Convert SCF dialect to ControlFlow dialect, replacing structured control flow with a CFG
  --convert-scf-to-emitc                             -   Convert SCF dialect to EmitC dialect, maintaining structured control flow
  --convert-scf-to-openmp                            -   Convert SCF parallel loop to OpenMP parallel + workshare constructs.
    --num-threads=<uint>                             - Number of threads to use
  --convert-scf-to-spirv                             -   Convert SCF dialect to SPIR-V dialect.
  --convert-shape-constraints                        -   Convert shape constraint operations to the standard dialect
  --convert-shape-to-std                             -   Convert operations from the shape dialect into the standard dialect
  --convert-spirv-to-llvm                            -   Convert SPIR-V dialect to LLVM dialect
    --client-api=<value>                             - Derive StorageClass to address space mapping from the client API
    =Unknown                                       -   Unknown (default)
    =Metal                                         -   Metal
    =OpenCL                                        -   OpenCL
    =Vulkan                                        -   Vulkan
    =WebGPU                                        -   WebGPU
  --convert-tensor-to-linalg                         -   Convert some Tensor dialect ops to Linalg dialect
  --convert-tensor-to-spirv                          -   Convert Tensor dialect to SPIR-V dialect
    --emulate-lt-32-bit-scalar-types                 - Emulate narrower scalar types with 32-bit ones if not supported by the target
  --convert-to-llvm                                  -   Convert to LLVM via dialect interfaces found in the input IR
    --dynamic                                        - Use op conversion attributes to configure the conversion
    --filter-dialects=<string>                       - Test conversion patterns of only the specified dialects
  --convert-to-spirv                                 -   Convert to SPIR-V
    --convert-gpu-modules                            - Clone and convert GPU modules
    --nest-in-gpu-module                             - Put converted SPIR-V module inside the gpu.module instead of alongside it.
    --run-signature-conversion                       - Run function signature conversion to convert vector types
    --run-vector-unrolling                           - Run vector unrolling to convert vector types in function bodies
  --convert-ub-to-llvm                               -   Convert UB dialect to LLVM dialect
    --index-bitwidth=<uint>                          - Bitwidth of the index type, 0 to use size of machine word
  --convert-ub-to-spirv                              -   Convert UB dialect to SPIR-V dialect
  --convert-vector-to-arm-sme                        -   Lower the operations from the vector dialect into the ArmSME dialect
  --convert-vector-to-gpu                            -   Lower the operations from the vector dialect into the GPU dialect
    --use-nvgpu                                      - convert to NvGPU ops instead of GPU dialect ops
  --convert-vector-to-llvm                           -   Lower the operations from the vector dialect into the LLVM dialect
    --enable-amx                                     - Enables the use of AMX dialect while lowering the vector dialect.
    --enable-arm-neon                                - Enables the use of ArmNeon dialect while lowering the vector dialect.
    --enable-arm-sve                                 - Enables the use of ArmSVE dialect while lowering the vector dialect.
    --enable-x86vector                               - Enables the use of X86Vector dialect while lowering the vector dialect.
    --force-32bit-vector-indices                     - Allows compiler to assume vector indices fit in 32-bit if that yields faster code
    --reassociate-fp-reductions                      - Allows llvm to reassociate floating-point reductions for speed
  --convert-vector-to-scf                            -   Lower the operations from the vector dialect into the SCF dialect
    --full-unroll                                    - Perform full unrolling when converting vector transfers to SCF
    --lower-scalable                                 - Add scalable vector specific lowerings (that introduce loops)
    --lower-tensors                                  - Lower transfer ops that operate on tensors
    --target-rank=<uint>                             - Target vector rank to which transfer ops should be lowered
  --convert-vector-to-spirv                          -   Convert Vector dialect to SPIR-V dialect
  --convert-vector-to-xegpu                          -   Lower the operations from the vector dialect into the XeGPU dialect
  --cse                                              -   Eliminate common sub-expressions
  --decorate-spirv-composite-type-layout             -   Decorate SPIR-V composite type with layout info
  --drop-equivalent-buffer-results                   -   Remove MemRef return values that are equivalent to a bbArg
  --duplicate-function-elimination                   -   Deduplicate functions
  --eliminate-empty-tensors                          -   Try to eliminate all tensor.empty ops.
  --empty-tensor-to-alloc-tensor                     -   Replace all empty ops by alloc_tensor ops.
  --enable-arm-streaming                             -   Enable Armv9 Streaming SVE mode
    --if-required-by-ops                             - Only apply the selected streaming/ZA modes if the function contains ops that implement the ArmSMETileOpInterface.
    --if-scalable-and-supported                      - Only apply the selected streaming/ZA modes if the function contains supported scalable vector operations.
    --streaming-mode=<value>                         - Select how streaming-mode is managed at the function-level.
    =disabled                                      -   Streaming mode is disabled.
    =streaming                                     -   Streaming mode is part of the function interface (ABI), caller manages PSTATE.SM on entry/exit.
    =streaming-locally                             -   Streaming mode is internal to the function, callee manages PSTATE.SM on entry/exit.
    =streaming-compatible                          -   Function supports both streaming and non-streaming modes.
    --za-mode=<value>                                - Select how ZA-storage is managed at the function-level.
    =disabled                                      -   ZA storage is disabled.
    =new-za                                        -   The function has ZA state. The ZA state is created on entry and destroyed on exit.
    =in-za                                         -   The function uses ZA state. The ZA state may be used for input.
    =out-za                                        -   The function uses ZA state. The ZA state may be used for output.
    =inout-za                                      -   The function uses ZA state. The ZA state may be used for input and/or output.
    =preserves-za                                  -   The function shares ZA state. The ZA state may not be used for input and/or output and the function must return with ZA unchanged
  --ensure-debug-info-scope-on-llvm-func             -   Materialize LLVM debug info subprogram attribute on every LLVMFuncOp
    --emission-kind=<value>                          - Emission kind to generate debug info.
    =None                                          -   None
    =Full                                          -   Full
    =LineTablesOnly                                -   LineTablesOnly (default)
    =DebugDirectivesOnly                           -   DebugDirectivesOnly
  --expand-realloc                                   -   Expand memref.realloc operations into its components
    --emit-deallocs                                  - Emit deallocation operations for the original MemRef
  --expand-strided-metadata                          -   Expand memref operations into easier to analyze constructs
  --finalize-memref-to-llvm                          -   Finalize MemRef dialect to LLVM dialect conversion
    --index-bitwidth=<uint>                          - Bitwidth of the index type, 0 to use size of machine word
    --use-aligned-alloc                              - Use aligned_alloc in place of malloc for heap allocations
    --use-generic-functions                          - Use generic allocation and deallocation functions instead of the classic 'malloc', 'aligned_alloc' and 'free' functions
  --fold-memref-alias-ops                            -   Fold memref alias ops into consumer load/store ops
  --fold-tensor-subset-ops                           -   Fold tensor subset ops into producer/consumer ops
  --form-expressions                                 -   Form C-style expressions from C-operator ops
  --generate-runtime-verification                    -   Generate additional runtime op verification checks
  --gpu-async-region                                 -   Make GPU ops async
  --gpu-decompose-memrefs                            -   Decomposes memref index computation into explicit ops.
  --gpu-eliminate-barriers                           -   Erase unnecessary barriers
  --gpu-kernel-outlining                             -   Outline gpu.launch bodies to kernel functions
    --data-layout-str=<string>                       - String containing the data layout specification to be attached to the GPU kernel module
  --gpu-launch-sink-index-computations               -   Sink index computations into gpu.launch body
  --gpu-map-parallel-loops                           -   Greedily maps loops to GPU hardware dimensions.
  --gpu-module-to-binary                             -   Transforms a GPU module into a GPU binary.
    --format=<string>                                - The target representation of the compilation process.
    -l <string>                                      - Extra files to link to.
    --opts=<string>                                  - Command line options to pass to the tools.
    --section=<string>                               - ELF section where binary is to be located.
    --toolkit=<string>                               - Toolkit path.
  --gpu-to-llvm                                      -   Convert GPU dialect to LLVM dialect with GPU runtime calls
    --type-check-kernel-args                         - Require all kernel arguments to be memrefs of rank 1 and with a 32-bit element size. This is a temporary option that will be removed; TODO(https://github.com/llvm/llvm-project/issues/73457).
    --use-bare-pointers-for-host                     - Use bare pointers to pass memref arguments to host functions. All memrefs must have static shape.
    --use-bare-pointers-for-kernels                  - Use bare pointers to pass memref arguments to kernels. The kernel must use the same setting for this option.
  --inline                                           -   Inline function calls
    --default-pipeline=<string>                      - The optimizer pipeline used for callables that do not have a dedicated optimizer pipeline in opPipelineList
    --inlining-threshold=<uint>                      - If the ratio between the number of the operations in the callee and the number of the operations in the caller exceeds this value (in percentage), then the callee is not inlined even if it is legal to inline it
    --max-iterations=<uint>                          - Maximum number of iterations when inlining within an SCC
    --op-pipelines=<pass-manager>                    - Callable operation specific optimizer pipelines (in the form of `dialect.op(pipeline)`)
  --int-range-optimizations                          -   Do optimizations based on integer range analysis
  --launch-func-to-vulkan                            -   Convert vulkanLaunch external call to Vulkan runtime external calls
  --lift-cf-to-scf                                   -   Lift ControlFlow dialect to SCF dialect
  --linalg-block-pack-matmul                         -   Convert linalg matmul ops to block layout and back
    --allow-padding                                  - Allow packing padding
    --block-factors=<long>                           - Block factors (mb, nb, kb) for relayout
    --lhs-transpose-inner-blocks                     - Transpose LHS inner block layout [mb][kb] -> [kb][mb]
    --lhs-transpose-outer-blocks                     - Transpose LHS outer block layout [MB][KB] -> [KB][MB]
    --mnk-order=<long>                               - Permutation of matmul (M, N, K) dimensions order
    --mnk-padded-multiples=<long>                    - Next multiples of the packing sizes
    --rhs-transpose-inner-blocks                     - Transpose RHS inner block layout [kb][nb] -> [nb][kb]
    --rhs-transpose-outer-blocks                     - Transpose RHS outer block layout [KB][NB] -> [NB][KB]
  --linalg-detensorize                               -   Detensorize linalg ops
    --aggressive-mode                                - Detensorize all ops that qualify for detensoring along with branch operands and basic-block arguments.
  --linalg-fold-unit-extent-dims                     -   Remove unit-extent dimension in Linalg ops on tensors
    --use-rank-reducing-slices                       - Generate rank-reducing slices instead of reassociative reshapes
  --linalg-fuse-elementwise-ops                      -   Fuse elementwise operations on tensors
  --linalg-generalize-named-ops                      -   Convert named ops into generic ops
  --linalg-inline-scalar-operands                    -   Inline scalar operands into linalg generic ops
  --linalg-named-op-conversion                       -   Convert from one named linalg op to another.
  --linalg-specialize-generic-ops                    -   Convert generic ops back to named ops
  --llvm-add-comdats                                 -   Add comdats to linkonce and linkonce_odr functions
  --llvm-legalize-for-export                         -   Legalize LLVM dialect to be convertible to LLVM IR
  --llvm-optimize-for-nvvm-target                    -   Optimize NVVM IR
  --llvm-request-c-wrappers                          -   Request C wrapper emission for all functions
  --loop-invariant-code-motion                       -   Hoist loop invariant instructions outside of the loop
  --loop-invariant-subset-hoisting                   -   Hoist loop invariant subset ops outside of the loop
  --lower-affine                                     -   Lower Affine operations to a combination of Standard and SCF operations
  --lower-host-to-llvm                               -   Lowers the host module code and `gpu.launch_func` to LLVM
  --lower-quant-ops                                  -   Lower quant.dcast and quant.qcast ops
  --lower-sparse-foreach-to-scf                      -   Decompose a complex sparse operation into multiple stages
  --lower-sparse-iteration-to-scf                    -   lower sparse_tensor.iterate/coiterate into scf loops
  --lower-sparse-ops-to-foreach                      -   Applies sparse tensor rewriting rules after sparsification
    --enable-convert                                 - Enable rewriting rules for the convert operator
    --enable-runtime-library                         - Enable runtime library for manipulating sparse tensors
  --lower-vector-mask                                -   Lower 'vector.mask' operations
  --lower-vector-multi-reduction                     -   Lower 'vector.multi_reduction' operations
    --lowering-strategy=<value>                      - Select the strategy to control how multi_reduction is lowered.
    =inner-parallel                                -   Lower multi_reduction into outer-reduction and inner-parallel ops.
    =inner-reduction                               -   Lower multi_reduction into outer-parallel and inner-reduction ops.
  --map-memref-spirv-storage-class                   -   Map numeric MemRef memory spaces to SPIR-V storage classes
    --client-api=<string>                            - The client API to use for populating mappings
  --math-extend-to-supported-types                   -   Legalize floating-point math ops on low-precision floats
    --extra-types=<string>                           - MLIR types with arithmetic support on a given target (f64 and f32 are implicitly supported)
    --target-type=<string>                           - MLIR type to convert the unsupported source types to
  --math-uplift-to-fma                               -   Uplift arith ops to math.fma.
  --mem2reg                                          -   Promotes memory slots into values.
    --region-simplify                                - Perform control flow optimizations to the region tree
  --memref-emulate-wide-int                          -   Emulate 2*N-bit integer operations using N-bit operations
    --widest-int-supported=<uint>                    - Widest integer type supported by the target
  --memref-expand                                    -   Legalize memref operations to be convertible to LLVM.
  --mesh-spmdization                                 -   Partition a function into SPMD form.
  --mlprogram-pipeline-globals                       -   Optimize `ml_program` global operations for read and store
  --normalize-memrefs                                -   Normalize memrefs
  --nvgpu-optimize-shared-memory                     -   Optimizes accesses to shard memory memrefs in order to reduce bank conflicts.
  --nvvm-attach-target                               -   Attaches an NVVM target attribute to a GPU Module.
    -O <uint>                                        - Optimization level.
    --chip=<string>                                  - Target chip.
    --fast                                           - Enable fast math mode.
    --features=<string>                              - Target features.
    --ftz                                            - Enable flush to zero for denormals.
    -l <string>                                      - Extra bitcode libraries paths to link to.
    --module=<string>                                - Regex used to identify the modules to attach the target to.
    --triple=<string>                                - Target triple.
  --one-shot-bufferize                               -   One-Shot Bufferize
    --allow-return-allocs-from-loops                 - Allows returning/yielding new allocations from a loop.
    --allow-unknown-ops                              - Allows unknown (not bufferizable) ops in the input IR.
    --analysis-fuzzer-seed=<uint>                    - Test only: Analyze ops in random order with a given seed (fuzzer)
    --analysis-heuristic=<string>                    - Heuristic that control the IR traversal during analysis
    --buffer-alignment=<ulong>                       - Sets the alignment of newly allocated buffers.
    --bufferize-function-boundaries                  - Bufferize function boundaries (experimental).
    --check-parallel-regions                         - Account for parallel regions in RaW analysis.
    --copy-before-write                              - Skip the analysis. Make a buffer copy on every write.
    --dialect-filter=<string>                        - Restrict bufferization to ops from these dialects.
    --dump-alias-sets                                - Test only: Annotate tensor IR with alias sets
    --function-boundary-type-conversion=<string>     - Controls layout maps when bufferizing function signatures.
    --must-infer-memory-space                        - The memory space of an memref types must always be inferred. If unset, a default memory space of 0 is used otherwise.
    --no-analysis-func-filter=<string>               - Skip analysis of functions with these symbol names.Set copyBeforeWrite to true when bufferizing them.
    --print-conflicts                                - Test only: Annotate IR with RaW conflicts. Requires test-analysis-only.
    --test-analysis-only                             - Test only: Only run inplaceability analysis and annotate IR
    --unknown-type-conversion=<string>               - Controls layout maps for non-inferrable memref types.
    --use-encoding-for-memory-space                  - Use the Tensor encoding attribute for the memory space. Exclusive to the 'must-infer-memory-space' option
  --openacc-legalize-data-values                     -   Legalizes SSA values in compute regions with results from data clause operations
    --apply-to-acc-data-construct                    - Replaces varPtr uses with accPtr for acc compute regions contained within acc.data or acc.declare region.
    --host-to-device                                 - Replace varPtr uses with accPtr if true. Replace accPtr uses with varPtr if false
  --optimize-allocation-liveness                     -   This pass optimizes the liveness of temp allocations in the input function
  --outline-shape-computation                        -   Using shape.func to preserve shape computation
  --ownership-based-buffer-deallocation              -   Adds all required dealloc operations for all allocations in the input program
    --private-function-dynamic-ownership             - Allows to add additional arguments to private functions to dynamically pass ownership of memrefs to callees. This can enable earlier deallocations.
  --pre-sparsification-rewrite                       -   Applies sparse tensor rewriting rules prior to sparsification
  --print-ir                                         -   Print IR on the debug stream
    --label=<string>                                 - Label
  --print-op-stats                                   -   Print statistics of operations
    --json                                           - print the stats as JSON
  --promote-buffers-to-stack                         -   Promotes heap-based allocations to automatically managed stack-based allocations
    --max-alloc-size-in-bytes=<uint>                 - Maximal size in bytes to promote allocations to stack.
    --max-rank-of-allocated-memref=<uint>            - Maximal memref rank to promote dynamic buffers.
  --reconcile-unrealized-casts                       -   Simplify and eliminate unrealized conversion casts
  --remove-dead-values                               -   Remove dead values
  --remove-shape-constraints                         -   Replace all cstr_ ops with a true witness
  --resolve-ranked-shaped-type-result-dims           -   Resolve memref.dim of result values of ranked shape type
  --resolve-shaped-type-result-dims                  -   Resolve memref.dim of result values
  --rocdl-attach-target                              -   Attaches a ROCDL target attribute to a GPU Module.
    -O <uint>                                        - Optimization level.
    --abi=<string>                                   - ABI version.
    --chip=<string>                                  - Target chip.
    --correct-sqrt                                   - Enable correct rounded sqrt.
    --daz                                            - Enable denormals are zero opt.
    --fast                                           - Enable fast relaxed math opt.
    --features=<string>                              - Target features.
    --finite-only                                    - Enable finite only opt.
    -l <string>                                      - Extra bitcode libraries paths to link to.
    --module=<string>                                - Regex used to identify the modules to attach the target to.
    --triple=<string>                                - Target triple.
    --unsafe-math                                    - Enable unsafe math opt.
    --wave64                                         - Use Wave64 mode.
  --sccp                                             -   Sparse Conditional Constant Propagation
  --scf-for-loop-canonicalization                    -   Canonicalize operations within scf.for loop bodies
  --scf-for-loop-peeling                             -   Peel `for` loops at their upper bounds.
    --peel-front                                     - Peel the first iteration out of the loop.
    --skip-partial                                   - Do not peel loops inside of the last, partial iteration of another already peeled loop.
  --scf-for-loop-range-folding                       -   Fold add/mul ops into loop range
  --scf-for-loop-specialization                      -   Specialize `for` loops for vectorization
  --scf-for-to-while                                 -   Convert SCF for loops to SCF while loops
  --scf-forall-to-for                                -   Convert SCF forall loops to SCF for loops
  --scf-forall-to-parallel                           -   Convert SCF forall loops to SCF parallel loops
  --scf-parallel-loop-fusion                         -   Fuse adjacent parallel loops
  --scf-parallel-loop-specialization                 -   Specialize parallel loops for vectorization
  --scf-parallel-loop-tiling                         -   Tile parallel loops
    --no-min-max-bounds                              - Perform tiling with fixed upper bound with inbound check inside the internal loops
    --parallel-loop-tile-sizes=<long>                - Factors to tile parallel loops by
  --set-llvm-module-datalayout                       -   Attach a datalayout string as a module attribute
    --data-layout=<string>                           - String description (LLVM format) of the data layout that is expected on the produced module
  --shape-to-shape-lowering                          -   Legalize Shape dialect to be convertible to Arith
  --sharding-propagation                             -   sharding propagation
  --snapshot-op-locations                            -   Generate new locations from the current IR
    --filename=<string>                              - The filename to print the generated IR
    --pretty-debuginfo                               - Print pretty debug info in MLIR output
    --print-debuginfo                                - Print debug info in MLIR output
    --print-local-scope                              - Print with local scope and inline information (eliding aliases for attributes, types, and locations
    --print-op-generic                               - Print the generic op form
    --tag=<string>                                   - A tag to use when fusing the new locations with the original. If unset, the locations are replaced.
  --sparse-assembler                                 -   Add [dis]assemble operations on external sparse tensors
    --direct-out                                     - Directly returns buffers externally
  --sparse-buffer-rewrite                            -   Rewrite sparse primitives on buffers to actual code
    --enable-buffer-initialization                   - Enable zero-initialization of the memory buffers
  --sparse-gpu-codegen                               -   Generates GPU code during sparsification
    --enable-runtime-library                         - Enable runtime library for manipulating sparse tensors
    --num-threads=<int>                              - Sets the number of GPU threads
  --sparse-reinterpret-map                           -   Reinterprets sparse tensor type mappings
    --scope=<value>                                  - Set the reiterpretation scope
    =all                                           -   Run on every applicable operations.
    =only-generic                                  -   Run only on linalg.generic operations.
    =except-generic                                -   Run on operations expect linalg.generic (e.g., foreach)
  --sparse-space-collapse                            -   sparse space collapsing pass
  --sparse-storage-specifier-to-llvm                 -   Lower sparse storage specifer to llvm structure
  --sparse-tensor-codegen                            -   Convert sparse tensors and primitives to actual code
    --create-sparse-deallocs                         - Specify if the temporary buffers created by the sparse compiler should be deallocated. For compatibility with core bufferization passes. This option is only used when enable-runtime-library=false. See also create-deallocs for BufferizationOption.
    --enable-buffer-initialization                   - Enable zero-initialization of the memory buffers
  --sparse-tensor-conversion                         -   Convert sparse tensors and primitives to library calls
  --sparse-vectorization                             -   Vectorizes loops after sparsification
    --enable-simd-index32                            - Enable i32 indexing into vectors (for efficient gather/scatter)
    --enable-vla-vectorization                       - Enable vector length agnostic vectorization
    --vl=<int>                                       - Set the vector length (use 0 to disable vectorization)
  --sparsification                                   -   Automatically generate sparse tensor code from sparse tensor types
    --enable-runtime-library                         - Enable runtime library for manipulating sparse tensors
    --parallelization-strategy=<value>               - Set the parallelization strategy
    =none                                          -   Turn off sparse parallelization.
    =dense-outer-loop                              -   Enable dense outer loop sparse parallelization.
    =any-storage-outer-loop                        -   Enable sparse parallelization regardless of storage for the outer loop.
    =dense-any-loop                                -   Enable dense parallelization for any loop.
    =any-storage-any-loop                          -   Enable sparse parallelization for any storage and loop.
    --sparse-emit-strategy=<value>                   - Emit functional code or interfaces (to debug) for sparse loops
    =functional                                    -   Emit functional code (with scf.for/while).
    =sparse-iterator                               -   Emit (experimental) loops (with sparse.iterate).
    =debug-interface                               -   Emit non-functional but easy-to-read interfaces to debug.
  --sparsification-and-bufferization                 -   Mini-pipeline that combines bufferization and sparsifiation
    --enable-gpu-libgen                              - Enable GPU acceleration by means of direct library calls
    --enable-simd-index32                            - Enable i32 indexing into vectors (for efficient gather/scatter)
    --enable-vla-vectorization                       - Enable vector length agnostic vectorization
    --parallelization-strategy=<value>               - Set the parallelization strategy
    =none                                          -   Turn off sparse parallelization.
    =dense-outer-loop                              -   Enable dense outer loop sparse parallelization.
    =any-storage-outer-loop                        -   Enable sparse parallelization regardless of storage for the outer loop.
    =dense-any-loop                                -   Enable dense parallelization for any loop.
    =any-storage-any-loop                          -   Enable sparse parallelization for any storage and loop.
    --sparse-emit-strategy=<value>                   - Emit functional code or interfaces (to debug) for sparse loops
    =functional                                    -   Emit functional code (with scf.for/while).
    =sparse-iterator                               -   Emit (experimental) loops (with sparse.iterate).
    =debug-interface                               -   Emit non-functional but easy-to-read interfaces to debug.
    --vl=<int>                                       - Set the vector length (use 0 to disable vectorization)
  --spirv-attach-target                              -   Attaches an SPIR-V target attribute to a GPU Module.
    --caps=<string>                                  - List of supported SPIR-V Capabilities
    --client_api=<string>                            - Client API
    --device_id=<uint>                               - Device ID
    --device_type=<string>                           - Device Type
    --exts=<string>                                  - List of supported SPIR-V Extensions
    --module=<string>                                - Regex used to identify the modules to attach the target to.
    --vendor=<string>                                - Device Vendor
    --ver=<string>                                   - SPIR-V Version.
  --spirv-canonicalize-gl                            -   Canonicalize GLSL ops
  --spirv-lower-abi-attrs                            -   Decorate SPIR-V composite type with layout info
  --spirv-rewrite-inserts                            -   Rewrite sequential chains of `spirv.CompositeInsert` operations into `spirv.CompositeConstruct` operations
  --spirv-unify-aliased-resource                     -   Unify access of multiple aliased resources into access of one single resource
  --spirv-update-vce                                 -   Deduce and attach minimal (version, capabilities, extensions) requirements to spirv.module ops
  --spirv-webgpu-prepare                             -   Prepare SPIR-V to target WebGPU by expanding unsupported ops and replacing with supported ones
  --sroa                                             -   Scalar Replacement of Aggregates
  --stage-sparse-ops                                 -   Decompose a complex sparse operation into multiple stages
  --strip-debuginfo                                  -   Strip debug info from all operations
  --strip-func-quant-types                           -   Strip quantized types from function headers
  --symbol-dce                                       -   Eliminate dead symbols
  --symbol-privatize                                 -   Mark symbols private
    --exclude=<string>                               - Comma separated list of symbols that should not be marked private
  --test-arm-sme-tile-allocation                     -   Tests SME 'virtual tile' allocation
    --dump-tile-live-ranges                          - Dump the live ranges of SME tiles (for debugging)
    --preprocess-only                                - Only preprocess IR so it is ready for tile allocation (but do not allocate any tiles)
  --test-scf-parallel-loop-collapsing                -   Test parallel loops collapsing transformation
    --collapsed-indices-0=<uint>                     - Which loop indices to combine 0th loop index
    --collapsed-indices-1=<uint>                     - Which loop indices to combine into the position 1 loop index
    --collapsed-indices-2=<uint>                     - Which loop indices to combine into the position 2 loop index
  --topological-sort                                 -   Sort regions without SSA dominance in topological order
  --tosa-infer-shapes                                -   Propagate shapes across TOSA operations
  --tosa-layerwise-constant-fold                     -   Fold layerwise operations on constant tensors
    --aggressive-reduce-constant                     - Always perform the reduce constant optimizationMay add more tosa.const but would reduce runtime calculations
  --tosa-make-broadcastable                          -   TOSA rank Reshape to enable Broadcasting
  --tosa-optional-decompositions                     -   Applies Tosa operations optional decompositions
  --tosa-reduce-transposes                           -   Reduce transposes through other operators
  --tosa-to-arith                                    -   Lower TOSA to the Arith dialect
    --include-apply-rescale                          - Whether to include the lowering for tosa.apply_rescale to arith
    --use-32-bit                                     - Whether to prioritze lowering to 32-bit operations
  --tosa-to-linalg                                   -   Lower TOSA to LinAlg on tensors
    --aggressive-reduce-constant                     - Always perform the reduce constant optimization
    --disable-tosa-decompositions                    - Disable tosa decompositions pass
  --tosa-to-linalg-named                             -   Lower TOSA to LinAlg named operations
    --prefer-conv2d-kernel-layout-hwcf               - Prefer generating linalg.conv_2d_nhwc_hwcf over linalg.conv_2d_nhwc_fhwc
  --tosa-to-mlprogram                                -   Lower TOSA to the MLProgram dialect
  --tosa-to-scf                                      -   Lower TOSA to the SCF dialect
  --tosa-to-tensor                                   -   Lower TOSA to the Tensor dialect
  --tosa-validate                                    -   Validates TOSA dialect
    --level=<value>                                  - Validate if operator parameters are within specfication for the given level
    =8k                                            -   Ranges are expected to be sufficient for applications with frame sizes up to 8K.
    =none                                          -   Allows the full range of arguments specified by the operations according to the operation data types.
    --profile=<string>                               - Validate if operations match for the given profile set
    --strict-op-spec-alignment                       - Verify if the properties of certain operations align the spec requirement
  --transform-dialect-check-uses                     -   warn about potential use-after-free in the transform dialect
  --transform-infer-effects                          -   infer transform side effects for symbols
  --transform-interpreter                            -   transform dialect interpreter
    --debug-bind-trailing-args=<string>              - Binds trailing arguments of the entry point to the payload operations with specified names.
    --debug-payload-root-tag=<string>                - Select the operation with 'transform.target_tag' attribute having the given value as payload IR root. If empty select the pass anchor operation as the payload IR root.
    --disable-expensive-checks                       - Disable expensive checks in the interpreter for a faster run.
    --entry-point=<string>                           - Entry point of the pass pipeline.
  --transform-preload-library                        -   preload transform dialect library
    --transform-library-paths=<string>               - Optional paths to files with modules that should be merged into the transform module to provide the definitions of external named sequences.
  --view-op-graph                                    -   Print Graphviz visualization of an operation
    --max-label-len=<uint>                           - Limit attribute/type length to number of chars
    --print-attrs                                    - Print attributes of operations
    --print-control-flow-edges                       - Print control flow edges
    --print-data-flow-edges                          - Print data flow edges
    --print-result-types                             - Print result types of operations
  --xegpu-fold-alias-ops                             -   Fold alias ops into XeGPU ops
